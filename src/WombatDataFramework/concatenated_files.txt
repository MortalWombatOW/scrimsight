## DataTypes.ts
import {node} from 'webpack';
import {getData, storeObjectInDatabase} from '../lib/data/database';
import alasql from 'alasql';

export type DataNodeName = string;

export class DataNodeExecution {
  private startTime: number;
  private endTime: number;
  private duration: number;
  private completed: boolean;
  private inputRows: number;
  private outputRows: number;
  private error?: string;

  constructor() {
    this.startTime = Date.now();
    this.completed = false;
    this.inputRows = 0;
    this.outputRows = 0;
  }

  public complete(inputRows: number, outputRows: number): void {
    if (this.completed) {
      throw new Error('Execution already completed');
    }
    this.endTime = Date.now();
    this.duration = this.endTime - this.startTime;
    this.completed = true;
    this.inputRows = inputRows;
    this.outputRows = outputRows;
  }

  public getDuration(): number {
    return this.duration;
  }

  public getCompleted(): boolean {
    return this.completed;
  }

  public getInputRows(): number {
    return this.inputRows;
  }

  public getOutputRows(): number {
    return this.outputRows;
  }

  public getError(): string | undefined {
    return this.error;
  }

  public setError(error: string): void {
    this.error = error;
  }

  public toString(): string {
    return `DataNodeExecution(${this.startTime}, ${this.endTime}, ${this.duration}, ${this.completed}, ${this.inputRows}, ${this.outputRows}, ${this.error})`;
  }
}

export interface DataNodeMetadata {
  executions: DataNodeExecution[];
}

export interface DataColumn<T extends object> {
  name: keyof T;
  missingData: boolean;
}

// This represents a node in the computation graph.
export abstract class DataNode<OutType extends object> {
  protected name: DataNodeName;
  protected displayName: string;
  protected columns: DataColumn<OutType>[];
  private output?: OutType[];
  protected metadata?: DataNodeMetadata;
  protected needsRun: boolean;
  constructor(
    name: DataNodeName,
    displayName: string,
    columns: (keyof OutType)[],
  ) {
    this.name = name;
    this.displayName = displayName;
    this.columns = columns.map((column) => ({
      name: column,
      missingData: false,
    }));
    this.needsRun = true;
  }
  public getName(): DataNodeName {
    return this.name;
  }
  public getDisplayName(): string {
    return this.displayName;
  }
  public getColumns(): DataColumn<OutType>[] {
    return this.columns;
  }
  public getOutput(): OutType[] | undefined {
    return this.output;
  }
  public getError(): string | undefined {
    return this.metadata?.executions
      .find((execution) => execution.getError() !== undefined)
      ?.getError();
  }
  public getMetadata(): DataNodeMetadata | undefined {
    return this.metadata;
  }
  public getLatestExecution(): DataNodeExecution {
    if (!this.metadata?.executions) {
      throw new Error('No executions');
    }
    return this.metadata?.executions[this.metadata?.executions.length - 1];
  }
  public getExecutionCount(): number {
    return this.metadata?.executions.length ?? 0;
  }
  protected setOutput(data: OutType[]): void {
    this.output = data;
  }

  public setNeedsRun(needsRun: boolean): void {
    this.needsRun = needsRun;
  }

  // public isTypeOf<T extends DataNode<any>>(
  //   constructor: new (...args: any[]) => T,
  // ): this is T {
  //   return this instanceof constructor;
  //
  public async run(sourceData?: any[]): Promise<void> {
    if (!this.metadata) {
      this.metadata = {
        executions: [],
      };
    } else if (!this.getLatestExecution().getCompleted()) {
      throw new Error('Last execution not completed');
    }
    this.setNeedsRun(false);
    this.metadata.executions.push(new DataNodeExecution());
    await this.runInner(sourceData);
    this.validateData();
  }

  protected abstract runInner(sourceData?: any[]): Promise<void>;
  public abstract getDependencies(): DataNodeName[];
  public abstract hasOutput(): boolean;

  public abstract getDescription(): string;

  public abstract canRun(): boolean;

  public isRunning(): boolean {
    return (
      this.metadata?.executions.some(
        (execution) => !execution.getCompleted(),
      ) ?? false
    );
  }

  public hasError(): boolean {
    return (
      !this.isRunning() &&
      (this.metadata?.executions.some(
        (execution) => execution.getError() !== undefined,
      ) ??
        false)
    );
  }
  public abstract toString(): string;

  private validateData(): void {
    // verify that all of the columns are present
    if (this.output === undefined) {
      return;
    }
    for (const item of this.output) {
      for (const column of this.getColumns().map((column) => column.name)) {
        if (item[column] === undefined) {
          throw new Error(
            `Column ${String(column)} is undefined for item ${item}`,
          );
        }
      }
      for (const field in item) {
        if (!this.columns.some((column) => column.name === field)) {
          throw new Error(
            `Field ${field} is not defined in columns for item ${item}`,
          );
        }
      }
    }

    this.labelColumnsMissingData();
  }
  private labelColumnsMissingData(): void {
    if (this.output === undefined || this.output.length === 0) {
      return;
    }
    for (const column of this.columns) {
      column.missingData = this.output.some(
        (item) => item[column.name] === undefined,
      );
    }
  }
}

// This represents a node that writes data to an object store.
export class WriteNode<Type extends object> extends DataNode<
  Record<string, never>
> {
  private data: Type[] = [];
  private objectStore: string;
  private inputColumns: (keyof Type)[];
  constructor(
    name: DataNodeName,
    displayName: string,
    objectStore: string,
    columns: (keyof Type)[],
  ) {
    super(name, displayName, []);
    this.objectStore = objectStore;
    this.inputColumns = columns;
  }

  validateInput(data: Type[]): void {
    for (const item of data) {
      for (const column of this.inputColumns) {
        if (item[column] === undefined) {
          throw new Error(`Column ${String(column)} is undefined`);
        }
      }
    }
  }

  async runInner(sourceData?: Type[]): Promise<void> {
    this.validateInput(this.data);
    for (const item of this.data) {
      await storeObjectInDatabase(item, this.objectStore);
    }
    this.getLatestExecution().complete(0, this.data.length);
    this.data = [];
  }
  getDependencies(): DataNodeName[] {
    return [];
  }
  getObjectStore(): string {
    return this.objectStore;
  }
  toString(): string {
    return `Write to ${this.objectStore}`;
  }
  addData(data: Type[]) {
    this.data.push(...data);
  }
  canRun(): boolean {
    return this.data.length > 0;
  }
  public hasOutput(): boolean {
    return true;
  }
  public getDescription(): string {
    return `Writes data to the ${this.objectStore} object store.`;
  }
}

// This represents a node that reads data from an object store.
export class ObjectStoreNode<OutType extends object> extends DataNode<OutType> {
  private objectStore: string;

  constructor(
    name: DataNodeName,
    displayName: string,
    objectStore: string,
    columns: (keyof OutType)[],
  ) {
    super(name, displayName, columns);
    this.objectStore = objectStore;
  }

  async runInner(sourceData?: any[]): Promise<void> {
    this.setOutput((await getData(this.objectStore)) as OutType[]);
    this.getLatestExecution().complete(0, this.getOutput()!.length);
  }

  getDependencies(): DataNodeName[] {
    return [this.objectStore + '_write_node'];
  }
  getObjectStore(): string {
    return this.objectStore;
  }
  toString(): string {
    return `Read from ${this.objectStore}`;
  }
  canRun(): boolean {
    return this.needsRun;
  }
  public hasOutput(): boolean {
    return this.getOutput() !== undefined;
  }
  public getDescription(): string {
    return `Reads data from the ${this.objectStore} object store.`;
  }
}

// This represents a node that executes an AlaSQL query on the data from the source nodes.
export class AlaSQLNode<OutType extends object> extends DataNode<OutType> {
  private sql: string;
  private sources: DataNodeName[];
  constructor(
    name: DataNodeName,
    displayName: string,
    sql: string,
    sources: DataNodeName[],
    columns: (keyof OutType)[],
  ) {
    super(name, displayName, columns);
    this.sql = sql;
    this.sources = sources;
  }
  async runInner(sourceData?: any[]): Promise<void> {
    const result = await alasql(this.sql, sourceData);
    this.setOutput(result);
    const inputRows = sourceData!.reduce(
      (sum, data) => sum + (data?.length ?? 0),
      0,
    );
    const outputRows = result.length;
    this.getLatestExecution().complete(inputRows, outputRows);
  }
  getDependencies(): DataNodeName[] {
    return this.sources;
  }
  toString(): string {
    return this.displayName;
  }
  canRun(): boolean {
    return this.needsRun;
  }
  changeSql(sql: string) {
    this.sql = sql;
  }
  public hasOutput(): boolean {
    return this.getOutput() !== undefined;
  }
  public getDescription(): string {
    return `Executes the following AlaSQL query: ${this.sql}`;
  }
}

export class PartitionNode<
  T extends object,
  PartitionFields extends object,
> extends DataNode<T & PartitionFields> {
  private partitionKey: keyof PartitionFields;
  private hasChange: (data1: T, data2: T) => boolean;
  private source: DataNodeName;

  constructor(
    name: DataNodeName,
    displayName: string,
    partitionKey: keyof PartitionFields,
    hasChange: (data1: T, data2: T) => boolean,
    source: DataNodeName,
    columns: (keyof T & keyof PartitionFields)[],
  ) {
    super(name, displayName, columns);
    this.partitionKey = partitionKey;
    this.hasChange = hasChange;
    this.source = source;
  }

  runInner(sourceData?: T[][]): Promise<void> {
    if (sourceData === undefined) {
      throw new Error('Source data is undefined');
    }

    const output: (T & PartitionFields)[] = [];
    // label the data with the partition key
    let currentId = 0;
    for (const [i, data1] of sourceData[0].entries()) {
      const copy: T & PartitionFields = {
        ...data1,
        [this.partitionKey]: currentId,
      } as T & PartitionFields;
      console.log(copy);
      output.push(copy);
      const data2 = sourceData[0][i + 1];
      if (data2 === undefined) {
        break;
      }
      if (this.hasChange(data1, data2)) {
        currentId++;
      }
    }
    console.log(output);

    this.setOutput(output);
    this.getLatestExecution().complete(sourceData[0].length, output.length);
    return Promise.resolve();
  }

  getDependencies(): DataNodeName[] {
    return [this.source];
  }

  toString(): string {
    return `Partition by ${String(this.partitionKey)}`;
  }

  canRun(): boolean {
    return this.needsRun;
  }

  public hasOutput(): boolean {
    return this.getOutput() !== undefined;
  }

  public getDescription(): string {
    return `Partitions the data based on the ${String(
      this.partitionKey,
    )} field.`;
  }
}

export class FilterNode<T extends object> extends DataNode<T> {
  private filterKey: keyof T;
  private filterValue: any;
  private source: DataNodeName;

  constructor(
    name: DataNodeName,
    displayName: string,
    filterKey: keyof T,
    filterValue: any,
    source: DataNodeName,
    columns: (keyof T)[],
  ) {
    super(name, displayName, columns);
    this.filterKey = filterKey;
    this.filterValue = filterValue;
    this.source = source;
  }

  runInner(sourceData?: T[]): Promise<void> {
    if (sourceData === undefined) {
      throw new Error('Source data is undefined');
    }

    const output = sourceData.filter(
      (data) => data[this.filterKey] === this.filterValue,
    );
    this.setOutput(output);
    this.getLatestExecution().complete(sourceData.length, output.length);
    return Promise.resolve();
  }

  getDependencies(): DataNodeName[] {
    return [this.source];
  }

  toString(): string {
    return `Filter by ${String(this.filterKey)} = ${String(this.filterValue)}`;
  }

  canRun(): boolean {
    return this.needsRun;
  }

  public hasOutput(): boolean {
    return this.getOutput() !== undefined;
  }

  public getDescription(): string {
    return `Filters the data where the ${String(
      this.filterKey,
    )} field is equal to ${String(this.filterValue)}.`;
  }
}

export class JoinNode<T1 extends object, T2 extends object> extends DataNode<
  T1 & T2
> {
  private joinKey: keyof T1 & keyof T2;
  private source1: DataNodeName;
  private source2: DataNodeName;

  constructor(
    name: DataNodeName,
    displayName: string,
    joinKey: keyof T1 & keyof T2,
    source1: DataNodeName,
    source2: DataNodeName,
    columns: (keyof T1 & keyof T2)[],
  ) {
    super(name, displayName, columns);
    this.joinKey = joinKey;
    this.source1 = source1;
    this.source2 = source2;
  }

  runInner(sourceData?: [T1[], T2[]]): Promise<void> {
    if (sourceData === undefined) {
      throw new Error('Source data is undefined');
    }

    const output: (T1 & T2)[] = [];
    for (const data1 of sourceData[0]) {
      for (const data2 of sourceData[1]) {
        const val1: any = data1[this.joinKey as keyof T1];
        const val2: any = data2[this.joinKey as keyof T2];
        if (val1 !== undefined && val2 !== undefined && val1 === val2) {
          output.push({...data1, ...data2});
        }
      }
    }

    this.setOutput(output);
    this.getLatestExecution().complete(
      sourceData[0].length + sourceData[1].length,
      output.length,
    );
    return Promise.resolve();
  }

  getDependencies(): DataNodeName[] {
    return [this.source1, this.source2];
  }

  toString(): string {
    return `Join on ${String(this.joinKey)}`;
  }

  getDescription(): string {
    return `Joins the data from ${this.source1} and ${
      this.source2
    } on the ${String(this.joinKey)} field.`;
  }

  canRun(): boolean {
    return this.needsRun;
  }

  public hasOutput(): boolean {
    return this.getOutput() !== undefined;
  }
}

## DataManager.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
import {DataNode, DataNodeName} from './DataTypes';

export class DataManager {
  private nodes: Map<DataNodeName, DataNode<any>>;
  private changeCallback: () => void;
  private nodeCallbacks: Map<DataNodeName, () => void>;

  constructor(changeCallback: () => void) {
    this.nodes = new Map();
    this.changeCallback = changeCallback;
    this.nodeCallbacks = new Map();
  }

  public nodesDependingOn(name: DataNodeName): DataNodeName[] {
    const nodes: DataNodeName[] = [];
    this.nodes.forEach((node) => {
      if (node.getDependencies().includes(name)) {
        nodes.push(node.getName());
      }
    });
    return nodes;
  }

  async executeNode(name: DataNodeName): Promise<void> {
    // console.group(`DataManager.executeNode(${name})`);
    const node = this.nodes.get(name);
    if (!node) {
      throw new Error(`Node ${name} does not exist`);
    }
    if (node.isRunning()) {
      console.log(`Node ${name} is already running`);
      console.groupEnd();
      return;
    }
    const dependencies = node.getDependencies();
    const sourceData = dependencies.map((dep) => {
      if (!this.nodes.get(dep)?.hasOutput()) {
        throw new Error(`Dependency ${dep} is empty, skipping ${name}`);
      }
      if (this.nodes.get(dep)?.isRunning()) {
        throw new Error(`Dependency ${dep} is running, skipping ${name}`);
      }
      return this.nodes.get(dep)?.getOutput();
    });

    try {
      await node.run(sourceData);
    } catch (e) {
      console.error(e);
    } finally {
      console.log(`Node ${name} finished, data:`, node.getOutput());
      // console.groupEnd();
      if (this.nodeCallbacks.has(name)) {
        console.log(`Executing callback for ${name}`);
        this.nodeCallbacks.get(name)!();
      }
    }
  }

  checkForCycles(): void {
    const visited: DataNodeName[] = [];
    const stack: DataNodeName[] = [];

    for (const node of this.nodes.keys()) {
      if (!visited.includes(node)) {
        if (this.isCyclic(node, visited, stack)) {
          throw new Error('Cycle detected');
        }
      }
    }
  }

  isCyclic(
    v: DataNodeName,
    visited: DataNodeName[],
    stack: DataNodeName[],
  ): boolean {
    if (stack.includes(v)) {
      return true;
    }
    if (visited.includes(v)) {
      return false;
    }
    visited.push(v);
    stack.push(v);

    const node = this.nodes.get(v);
    if (!node) {
      throw new Error(`Node ${v} does not exist`);
    }
    for (const node of this.nodesDependingOn(v)) {
      if (this.isCyclic(node, visited, stack)) {
        return true;
      }
    }
    stack.pop();
    return false;
  }

  setNode(node: DataNode<any>): void {
    if (this.nodes.has(node.getName())) {
      console.log(`Node ${node.getName()} already exists`);
      return;
    }
    console.log(`Adding node ${node.getName()}`);
    this.checkForCycles();
    this.nodes.set(node.getName(), node);
  }

  setNodes(nodes: DataNode<any>[]): void {
    for (const node of nodes) {
      this.setNode(node);
    }
  }

  addNodeCallback(name: DataNodeName, callback: () => void): void {
    this.nodeCallbacks.set(name, callback);
  }

  getNodeOrDie(name: DataNodeName): DataNode<any> {
    const node = this.nodes.get(name);
    if (!node) {
      throw new Error(`Node ${name} does not exist`);
    }
    return node;
  }

  getNextNodeToExecute(): DataNode<any> | undefined {
    const nodes = this.getNodesToExecute();
    if (nodes.length === 0) {
      return undefined;
    }
    return nodes[0];
  }

  getNodesToExecute(): DataNode<any>[] {
    const visited: string[] = [];
    const stack: string[] = [];

    for (const node of this.nodes.keys()) {
      if (!visited.includes(node)) {
        this.topoSort(node, visited, stack);
      }
    }

    return stack
      .filter(
        (name) =>
          this.getNodeOrDie(name).canRun() &&
          !this.getNodeOrDie(name).isRunning(),
      )
      .map((name) => this.getNodeOrDie(name));
  }

  private topoSort(v: string, visited: string[], stack: string[]): void {
    if (visited.includes(v)) {
      return;
    }
    visited.push(v);
    for (const node of this.getNodeOrDie(v).getDependencies()) {
      if (!visited.includes(node)) {
        this.topoSort(node, visited, stack);
      }
    }
    stack.push(v);
  }

  async process(): Promise<void> {
    let nodes = this.getNodesToExecute();
    while (nodes.length > 0) {
      for (const node of nodes) {
        await this.executeNode(node.getName());
      }
      nodes = this.getNodesToExecute();
    }
  }

  markNode(name: DataNodeName): void {
    const node = this.getNodeOrDie(name);
    node.setNeedsRun(true);
    const nodes = this.nodesDependingOn(name);
    nodes.forEach((node) => this.markNode(node));
  }

  getNodeOutputOrDie(name: DataNodeName): any {
    const node = this.getNodeOrDie(name);
    if (!node.hasOutput()) {
      throw new Error(`Node ${name} has no output`);
    }
    return node.getOutput();
  }

  getNodes(): DataNode<any>[] {
    return [...this.nodes.values()];
  }
}

## DataManager.test.ts
/* eslint-disable @typescript-eslint/no-empty-function */
import {DataManager} from './DataManager';
import {AlaSQLNode, ObjectStoreNode, WriteNode} from './DataTypes';

describe('DataManager', () => {
  test('should add a node to the graph and execute it', async () => {
    const dm = new DataManager(() => {});

    dm.setNode(
      new AlaSQLNode<{num: number}>(
        'a',
        'Node A',
        'SELECT 1 as num',
        [],
        ['num'],
      ),
    );

    expect(dm.getNodeOrDie('a').isRunning()).toBe(false);
    expect(dm.getNodeOrDie('a').hasError()).toBe(false);
    expect(dm.getNodeOrDie('a').hasOutput()).toBe(false);

    await dm.executeNode('a');

    const output = dm.getNodeOutputOrDie('a');
    expect(output[0].num).toBe(1);

    const execution = dm.getNodeOrDie('a').getLatestExecution();
    expect(execution.getCompleted()).toBe(true);
    expect(execution.getError()).toBe(undefined);
    expect(execution.getDuration()).toBeGreaterThan(0);
    expect(execution.getInputRows()).toBe(0);
    expect(execution.getOutputRows()).toBe(1);
  });

  test('basic data flow', async () => {
    const dm = new DataManager(() => {});

    dm.setNodes([
      new AlaSQLNode<{num: number}>(
        'a',
        'Node A',
        'SELECT 1 as num',
        [],
        ['num'],
      ),
      new AlaSQLNode<{num: number}>(
        'b',
        'Node B',
        'SELECT * FROM ?',
        ['a'],
        ['num'],
      ),
    ]);

    await dm.process();

    expect(dm.getNodeOrDie('b').getOutput()).toEqual([{num: 1}]);
  });

  test('basic data flow with multiple inputs', async () => {
    const dm = new DataManager(() => {});

    dm.setNodes([
      new AlaSQLNode<{id: number; num: number}>(
        'a',
        'Node A',
        'SELECT 1 as id, 2 as num',
        [],
        ['id', 'num'],
      ),
      new AlaSQLNode<{id: number; str: number}>(
        'b',
        'Node B',
        'SELECT 1 as id,  2 as str',
        [],
        ['id', 'str'],
      ),
      new AlaSQLNode<{id: number; num: number; str: number}>(
        'c',
        'Node C',
        'SELECT * FROM ? as a JOIN ? as b ON a.id = b.id',
        ['a', 'b'],
        ['id', 'num', 'str'],
      ),
    ]);

    expect(dm.getNodesToExecute().length).toBe(3);
    await dm.process();
    expect(dm.getNodesToExecute().length).toBe(0);

    expect(dm.getNodeOutputOrDie('c')).toEqual([{id: 1, num: 2, str: 2}]);
  });

  test('change propagation', async () => {
    const dm = new DataManager(() => {});

    dm.setNodes([
      new AlaSQLNode<{num: number}>(
        'a',
        'Node A',
        'SELECT 1 as num',
        [],
        ['num'],
      ),
      new AlaSQLNode<{num: number}>(
        'b',
        'Node B',
        'SELECT * FROM ?',
        ['a'],
        ['num'],
      ),
    ]);

    expect(dm.getNodesToExecute().map((node) => node.getName())).toEqual([
      'a',
      'b',
    ]);
    await dm.process();
    expect(dm.getNodesToExecute().map((node) => node.getName())).toEqual([]);

    expect(dm.getNodeOrDie('b').getOutput()).toEqual([{num: 1}]);

    (dm.getNodeOrDie('a') as AlaSQLNode<{num: number}>).changeSql(
      'SELECT 2 as num',
    );
    dm.markNode('a');

    expect(dm.getNodesToExecute().map((node) => node.getName())).toEqual([
      'a',
      'b',
    ]);
    await dm.process();

    expect(dm.getNodeOrDie('b').getOutput()).toEqual([{num: 2}]);
  });

  test('topological sort', async () => {
    const dm = new DataManager(() => {});

    dm.setNodes([
      new AlaSQLNode<{num: number}>(
        'c',
        'Node C',
        'SELECT * FROM ?',
        ['b'],
        ['num'],
      ),
      new AlaSQLNode<{num: number}>(
        'b',
        'Node B',
        'SELECT * FROM ?',
        ['a'],
        ['num'],
      ),
      new AlaSQLNode<{num: number}>(
        'a',
        'Node A',
        'SELECT 1 as num',
        [],
        ['num'],
      ),
    ]);

    expect(dm.getNodesToExecute().map((node) => node.getName())).toEqual([
      'a',
      'b',
      'c',
    ]);
    await dm.process();
    expect(dm.getNodesToExecute().map((node) => node.getName())).toEqual([]);

    expect(dm.getNodeOrDie('c').getOutput()).toEqual([{num: 1}]);
  });
});

## DataContext.tsx
import React, {useContext, useEffect, useState} from 'react';
import {DataManager} from './DataManager';
import {NODES} from '../lib/data/NodeData';

const DataContext = React.createContext<DataManager | null>(null);

const DataProvider = ({children, globalTick, updateGlobalCallback}) => {
  const dataManager = useState(() => new DataManager(updateGlobalCallback))[0];
  dataManager.setNodes(NODES);
  useEffect(() => {
    const fetchData = async () => {
      await dataManager.process();
    };

    fetchData();
  }, [dataManager]);

  console.log('Rendering data, tick = ', globalTick);

  return (
    <DataContext.Provider value={dataManager}>{children}</DataContext.Provider>
  );
};

const useDataManager = () => {
  const dataManager = useContext(DataContext);
  if (!dataManager) {
    throw new Error('useDataManager must be used within a DataProvider');
  }
  return dataManager;
};

export {DataProvider, DataContext, useDataManager};

